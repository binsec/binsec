# How to \#1: Solving self-modifying CTF with BINSEC SSE

In this post, we will exercise the **S**tatic **S**ymbolic **E**xecution engine of **BINSEC** over the [pjenik@seznam.cz](https://crackmes.one/user/pjenik@seznam.cz) challenge `Hidden password`.  
The goal of the challenge is to find the password given on the command line
such that the prompt is `Good password!`. It is a `x86-64` shared file but you know it is not a problem -- as [a reminder](intermediates_2.md), we can generate a core dump to setup the analysis.

So, it will be easy right? Well... we may have to introduce three new concepts
before you find the much-prized password.

### Setup

We first need to download the [challenge archive](https://crackmes.one/static/crackme/61ffb07c33c5d46c8bcbfc1d.zip) and extract its content.
```console
$ wget  https://crackmes.one/static/crackme/61ffb07c33c5d46c8bcbfc1d.zip
$ unzip -P crackmes.one 61ffb07c33c5d46c8bcbfc1d.zip
```

### Working with stripped binaries

Having difficulties to break at `main` when there is no `main` symbol?  
We can enrich the GDB script to deal with this little inconvenience.
```
set interactive-mode off
set pagination off
set breakpoint pending on
set env LD_BIND_NOW=1
set env GLIBC_TUNABLES=glibc.cpu.hwcaps=-AVX2_Usable
b __libc_start_main
run
b *$rdi
continue
generate-core-file core.snapshot
kill
quit
```
Run the above script with the following command to generate core-dump:
```
$ gdb -x <script_name> --args ./hidden_password aaaaaaaaaaaaaaaaaaa
```

### `starting with` syntax

In addition to the `starting from core` command, we can specify a piece of
*DBA* code -- the same way `replace by` command works -- that will be evaluated before the analysis start.

This is particularly usefull here since the symbolic input should already be in memory at the entry point (`argv`) -- previously, the symbolic input came from a function like `ReadFile` or `__isoc99_scanf`.

For instance, we will initialize the first argument of `argv` with the following.
```
starting from core with
  argv<64> := rsi
  arg1<64> := @[argv + 8, 8]
  size<64> := nondet            # 0 < strlen(argv[1]) < 128
  assume 0 < size < 128
  all_printables<1> := true
  @[arg1, 128] := 0
  for i<64> in 0 to size - 1 do
    @[arg1 + i] := nondet as password
    all_printables := all_printables && " " <= password <= "~"
  end
  assume all_printables
end
```

### Self-written instructions

If you launch **BINSEC** on the core dump generated by GDB, you will see the following warning.
```
[sse:warning] Section "load" [0x7ffffffdd000, 139264] has both Write and Execute flags.
              Self-modifying code is disabled and writes will be ignored.
              Use '-sse-self-written-enum N' to enable symbolic reasoning up to 'N - 1' forks.
```

The loader informs you that one of the section, *most likely the stack*, has been given the **X** flag. It is quite unusual since modern operating system generally try to enforce **W^X** policy.

By default, **BINSEC** will ignore the changes in this section when it comes to execute instructions as if instruction cache was totally disjoint from the main memory.

However, it is possible to use the `-sse-self-written-enum` option to change this behavior. By setting `N` to a positive value, the symbolic engine will enumerate up to `N` different opcode values and fork accordingly.
Be aware that a big value may dramatically impact the performance since the number of paths to explore will increase exponentially.

Still, if we have good reasons to think that the code being written is constant (e.g. code unpacked at runtime), setting `N` to 1 offer the best performance tradeoff since the engine will take into account the written value without inquiring forks.

### Solution

The solution script is given [here](../../examples/sse/crackmes/hidden_password/crackme.ini) and the command is the following.
```console
$ binsec -sse -sse-script crackme.ini -sse-depth 10000 \
  -sse-self-written-enum 1 core.snapshot
```
Then is the solution.
```
[sse:result] Ascii stream password : "hello_world_42"
[sse:info] SMT queries
             Preprocessing simplifications
               total          4556
               sat            1479
               unsat          1704
               constant enum  1373
             
             Satisfiability queries
               total          188
               sat            56
               unsat          132
               unknown        0
               time           122.44
               average        0.65
             
           Exploration
             total paths                      43
             completed/cut paths              41
             pending paths                    2
             stale paths                      0
             failed assertions                0
             branching points                 4186
             max path depth                   8060
             visited instructions (unrolled)  27575
             visited instructions (static)    212
```

### Conclusion

Self-modifying code could be really challenging and may aggravate the path
explosion issue of symbolic execution.

Yet, in practice, self-modifying code is used to hinder static disassembly.
The actual code is simply hidden, waiting to be unpacked  -- this kind of protection does not prevent dynamic analysis -- and starting from now, **BINSEC** -- to reason over it. 

Have a nice day :-)


